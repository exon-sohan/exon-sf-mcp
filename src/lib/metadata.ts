import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import { executeSfCommand } from "./sf-command.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export function registerMetadataTools(server: McpServer) {
    /**
     * @description Creates a custom object in Salesforce.
     */
    server.tool(
        "create_custom_object",
        "Creates a custom object in Salesforce org.", {
        input: z.object({
        targetOrg: z.string().describe("Target Salesforce Org alias or username."),
        objectName: z.string().describe("Name of the custom object (e.g., 'MyCustomObject')."),
        label: z.string().describe("Label for the custom object."),
        pluralLabel: z.string().describe("Plural label for the custom object."),
        description: z.string().optional().describe("Description of the custom object."),
        apiVersion: z.string().default("59.0").describe("API version."),
        }),
    },
    async ({ input }) => {
        const { targetOrg, objectName, label, pluralLabel, description, apiVersion } = input;
        
        const tempDir = path.join(__dirname, 'temp_object_deploy');
        const objectsDir = path.join(tempDir, 'objects');
        await fs.mkdir(objectsDir, { recursive: true });

        const objectPath = path.join(objectsDir, `${objectName}__c.object-meta.xml`);

        const objectContent = `<?xml version="1.0" encoding="UTF-8"?>
                                    <CustomObject xmlns=\"http://soap.sforce.com/2006/04/metadata\">
                                        <actionOverrides>
                                            <actionName>Accept</actionName>
                                            <type>Default</type>
                                        </actionOverrides>
                                        <allowInChatterGroups>false</allowInChatterGroups>
                                        <compactLayoutAssignment>SYSTEM</compactLayoutAssignment>
                                        <deploymentStatus>Deployed</deploymentStatus>
                                        <description>${'Generated by sf-mcp'+ ' ' + description || ''}</description>
                                        <enableActivities>true</enableActivities>
                                        <enableBulkApi>true</enableBulkApi>
                                        <enableFeeds>false</enableFeeds>
                                        <enableHistory>true</enableHistory>
                                        <enableLicensing>false</enableLicensing>
                                        <enableReports>true</enableReports>
                                        <enableSearch>true</enableSearch>
                                        <enableSharing>true</enableSharing>
                                        <enableStreamingApi>true</enableStreamingApi>
                                        <label>${label}</label>
                                        <nameField>
                                            <label>${objectName} Name</label>
                                            <type>Text</type>
                                        </nameField>
                                        <pluralLabel>${pluralLabel}</pluralLabel>
                                        <searchLayouts/>
                                        <sharingModel>ReadWrite</sharingModel>
                                        <visibility>Public</visibility>
                                    </CustomObject>`;

        await fs.writeFile(objectPath, objectContent);

        const sfCommand = `sf project deploy start --source-dir \"${tempDir}\" --target-org ${targetOrg} --json`;

        try {
        const result = await executeSfCommand(sfCommand);
        return {
            content: [{
            type: "text",
            text: `Successfully created custom object '${objectName}__c'.\n${JSON.stringify(result, null, 2)}`
            }],
        };
        } finally {
        await fs.rm(tempDir, { recursive: true, force: true });
        }
    }
    );

    /**
     * @description Creates a simple flow in Salesforce.
     */
    server.tool(
    "create_flow",
    "Creates a simple flow in Salesforce org.", {
        input: z.object({
        targetOrg: z.string().describe("Target Salesforce Org alias or username."),
        flowName: z.string().describe("Name of the flow to create."),
        flowType: z.enum(["AutoLaunchedFlow", "Flow", "Workflow"]).default("Flow").describe("Type of flow to create."),
        apiVersion: z.string().default("59.0").describe("API version."),
        }),
    },
    async ({ input }) => {
        const { targetOrg, flowName, flowType, apiVersion } = input;
        
        const tempDir = path.join(__dirname, 'temp_flow_deploy');
        const flowsDir = path.join(tempDir, 'flows');
        await fs.mkdir(flowsDir, { recursive: true });

        const flowPath = path.join(flowsDir, `${flowName}.flow-meta.xml`);

        const flowContent = `<?xml version="1.0" encoding="UTF-8"?>
<Flow xmlns=\"http://soap.sforce.com/2006/04/metadata\">
    <apiVersion>${apiVersion}</apiVersion>
    <description>Auto-generated flow: ${flowName}</description>
    <label>${flowName}</label>
    <processMetadataValues>
        <name>BuilderType</name>
        <value>
            <stringValue>LightningFlowBuilder</stringValue>
        </value>
    </processMetadataValues>
    <processType>${flowType}</processType>
    <start>
        <locationX>50</locationX>
        <locationY>0</locationY>
        <connector>
            <targetReference>Screen_Welcome</targetReference>
        </connector>
    </start>
    <screens>
        <name>Screen_Welcome</name>
        <label>Welcome Screen</label>
        <locationX>50</locationX>
        <locationY>158</locationY>
        <allowBack>false</allowBack>
        <allowFinish>true</allowFinish>
        <allowPause>false</allowPause>
        <fields>
            <name>Welcome_Text</name>
            <fieldText>&lt;p&gt;Welcome to ${flowName}!&lt;/p&gt;</fieldText>
            <fieldType>DisplayText</fieldType>
        </fields>
        <showFooter>true</showFooter>
        <showHeader>true</showHeader>
    </screens>
    <status>Draft</status>
</Flow>`;

        await fs.writeFile(flowPath, flowContent);

        const sfCommand = `sf project deploy start --source-dir \"${tempDir}\" --target-org ${targetOrg} --json`;

        try {
        const result = await executeSfCommand(sfCommand);
        return {
            content: [{
            type: "text",
            text: `Successfully created flow '${flowName}'.\n${JSON.stringify(result, null, 2)}`
            }],
        };
        } finally {
        await fs.rm(tempDir, { recursive: true, force: true });
        }
    }
    );

    /**
     * @description Lists flows in the Salesforce org.
     */
    server.tool(
    "list_flows",
    "Lists all flows in the Salesforce org.", {
        input: z.object({
        targetOrg: z.string().describe("Target Salesforce Org alias or username."),
        status: z.enum(["Active", "Draft", "Obsolete", "InvalidDraft"]).optional().describe("Filter by flow status."),
        }),
    },
    async ({ input }) => {
        const { targetOrg, status } = input;
        
        let query = "SELECT Id, MasterLabel, DeveloperName, ProcessType, Status, Description FROM FlowDefinition";
        if (status) {
        query += ` WHERE Status = '${status}'`;
        }
        
        const sfCommand = `sf data query --target-org ${targetOrg} --query \"${query}\" --json`;
        const result = await executeSfCommand(sfCommand);
        
        return {
        content: [{
            type: "text",
            text: `Flows in org:\n${JSON.stringify(result.result.records, null, 2)}`
        }],
        };
    }
    );

    /**
     * @description Activates a flow in Salesforce.
     */
    server.tool(
    "activate_flow",
    "Activates a flow in Salesforce org.", {
        input: z.object({
        targetOrg: z.string().describe("Target Salesforce Org alias or username."),
        flowApiName: z.string().describe("API name of the flow to activate."),
        }),
    },
    async ({ input }) => {
        const { targetOrg, flowApiName } = input;
        
        const apexCode = `
Flow.Interview.createInterview('${flowApiName}', new Map<String, Object>());
// Activate flow using Tooling API would require more complex implementation
System.debug('Flow activation requested for: ${flowApiName}');
`;
        
        const tempFilePath = path.join(__dirname, 'temp_activate_flow.apex');
        await fs.writeFile(tempFilePath, apexCode);

        const sfCommand = `sf apex run --file \"${tempFilePath}\" --target-org ${targetOrg} --json`;

        try {
        const result = await executeSfCommand(sfCommand);
        return {
            content: [{
            type: "text",
            text: `Flow activation requested for '${flowApiName}'.\n${JSON.stringify(result, null, 2)}\nNote: Manual activation in Setup may be required.`
            }],
        };
        } finally {
        await fs.unlink(tempFilePath);
        }
    }
    );

    /**
     * @description Runs a flow interview in Salesforce.
     */
    server.tool(
    "run_flow",
    "Runs a flow interview in Salesforce org.", {
        input: z.object({
        targetOrg: z.string().describe("Target Salesforce Org alias or username."),
        flowApiName: z.string().describe("API name of the flow to run."),
        inputVariables: z.record(z.any()).optional().describe("Input variables for the flow as key-value pairs."),
        }),
    },
    async ({ input }) => {
        const { targetOrg, flowApiName, inputVariables = {} } = input;
        
        const inputVarsString = Object.entries(inputVariables)
        .map(([key, value]) => `'${key}' => '${value}'`)
        .join(', ');
        
        const apexCode = `
Map<String, Object> inputs = new Map<String, Object>{${inputVarsString}};
Flow.Interview flowInterview = Flow.Interview.createInterview('${flowApiName}', inputs);
flowInterview.start();
System.debug('Flow executed successfully: ${flowApiName}');
System.debug('Flow outputs: ' + flowInterview.getVariableValue('outputVariable'));
`;
        
        const tempFilePath = path.join(__dirname, 'temp_run_flow.apex');
        await fs.writeFile(tempFilePath, apexCode);

        const sfCommand = `sf apex run --file \"${tempFilePath}\" --target-org ${targetOrg} --json`;

        try {
        const result = await executeSfCommand(sfCommand);
        return {
            content: [{
            type: "text",
            text: `Flow '${flowApiName}' executed.\n${JSON.stringify(result, null, 2)}`
            }],
        };
        } finally {
        await fs.unlink(tempFilePath);
        }
    }
    );

    /**
     * @description Deploys source code to Salesforce org.
     */
    server.tool(
    "deploy_source",
    "Deploys source code from local directory to Salesforce org.", {
        input: z.object({
        targetOrg: z.string().describe("Target Salesforce Org alias or username."),
        sourceDir: z.string().describe("Source directory to deploy."),
        checkOnly: z.boolean().default(false).describe("Perform validation deploy only (check-only)."),
        testLevel: z.enum(["NoTestRun", "RunLocalTests", "RunAllTestsInOrg", "RunSpecifiedTests"]).default("RunLocalTests").describe("Test level for deployment."),
        ignoreWarnings: z.boolean().default(false).describe("Ignore warnings during deployment."),
        }),
    },
    async ({ input }) => {
        const { targetOrg, sourceDir, checkOnly, testLevel, ignoreWarnings } = input;
        
        let sfCommand = `sf project deploy start --source-dir \"${sourceDir}\" --target-org ${targetOrg} --test-level ${testLevel} --json`;
        
        if (checkOnly) {
        sfCommand += " --dry-run";
        }
        
        if (ignoreWarnings) {
        sfCommand += " --ignore-warnings";
        }

        const result = await executeSfCommand(sfCommand);
        return {
        content: [{
            type: "text",
            text: `Deployment ${checkOnly ? '(validation)' : ''} completed.\n${JSON.stringify(result, null, 2)}`
        }],
        };
    }
    );

    /**
     * @description Retrieves source code from Salesforce org.
     */
    server.tool(
    "retrieve_source",
    "Retrieves source code from Salesforce org.", {
        input: z.object({
        targetOrg: z.string().describe("Target Salesforce Org alias or username."),
        metadata: z.array(z.string()).describe("Metadata types to retrieve (e.g., ['ApexClass', 'LightningComponentBundle'])."),
        targetDir: z.string().optional().describe("Target directory for retrieved source."),
        }),
    },
    async ({ input }) => {
        const { targetOrg, metadata, targetDir } = input;
        
        let sfCommand = `sf project retrieve start --target-org ${targetOrg} --metadata ${metadata.join(',')} --json`;
        
        if (targetDir) {
        sfCommand += ` --target-dir \"${targetDir}\"`;
        }

        const result = await executeSfCommand(sfCommand);
        return {
        content: [{
            type: "text",
            text: `Source retrieval completed.\n${JSON.stringify(result, null, 2)}`
        }],
        };
    }
    );

    /**
     * @description Describes a Salesforce object and its fields.
     */
    server.tool(
    "describe_object",
    "Describes a Salesforce object and its fields.", {
        input: z.object({
        targetOrg: z.string().describe("Target Salesforce Org alias or username."),
        objectName: z.string().describe("Name of the object to describe."),
        }),
    },
    async ({ input }) => {
        const { targetOrg, objectName } = input;
        
        const sfCommand = `sf sobject describe --sobject ${objectName} --target-org ${targetOrg} --json`;
        const result = await executeSfCommand(sfCommand);
        
        return {
        content: [{
            type: "text",
            text: `Object Description for '${objectName}':\n${JSON.stringify(result, null, 2)}`
        }],
        };
    }
    );
}
